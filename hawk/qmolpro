#!/bin/sh
prefix='q'
this=`basename $0`
prog=${this#${prefix}}

# configuration
#Include this if workers have different core count to head, or if you want for other reasons to configure manually
#max_tasks_per_node=16 

if [ -z "$max_tasks_per_node" ]; then uname=$(uname); test $uname = Darwin && max_tasks_per_node=$(sysctl -n hw.ncpu) || max_tasks_per_node=$(nproc||echo 1) ; fi

#default
if [ x${PROJECT} = x ]; then
    defaultoptions="-d /scratch/$USER -P none"
else
    defaultoptions="-d /scratch/$USER"
fi
                                                                                
# parse options
systemconfigfile=$0.rc
#echo systemconfigfile=$systemconfigfile
#ls -l $systemconfigfile
configfile=${HOME}/.${this}rc
test -r $systemconfigfile && systemconfigfileoptions=$(cat ${systemconfigfile})
test -r $configfile && configfileoptions=$(cat ${configfile})
#echo systemconfigfileoptions=$systemconfigfileoptions
#echo configfileoptions=$configfileoptions
#echo defaultoptions=$defaultoptions
set -- `getopt gd:vW:t:n:l:q:x:P:m:N: $defaultoptions $systemconfigfileoptions $configfileoptions $*`
parse_opts=0
MEMORY=
TASKS_PER_NODE=
while [ "$1" != -- ]; do
# echo option $1 $2
  case "$1" in
    -d) eval scratchdir="$2"; shift;;
    -g) debug=1 ;;
    -v) verbose=1 ;;
    -k) keeptmp=1 ;;
    -W) OPTION="$OPTION $2"; shift;;
    -l) SBATCHARGS=$(echo $SBATCHARGS -l $2 | sed -e '/s/,/ /g'); shift;;
    -m) echo m option $2; MEMORY=$2; shift;;
    -n) NOPTION=$2; shift;;
    -N) TASKS_PER_NODE=$2; shift;;
    -t) OPTION="$OPTION $1 $2"; THREADS=$2; shift;;
    -q) QUEUE=$2; shift;;
    -P) PROJECT=$2; shift;;
    -x) garbage=$2; shift;;
     *) parse_opts=1;;
  esac
  shift
done
shift

# hardware
if [ x${QUEUE} = xcompute  -o x${QUEUE} = xdev ]; then
    hardware_memory=182
    hardware_cores=40
elif [ x${QUEUE} = xhighmem ]; then
    hardware_memory=374
    hardware_cores=40
else # should be htc
    QUEUE=htc
    hardware_memory=182
    hardware_cores=40
    if [ x${NOPTION} = x ]; then NOPTION=1 ; fi
    if [ x${MEMORY} = x ]; then
	MEMORY=$(echo "import math; print(int(math.floor(128.0*${hardware_memory}/${hardware_cores})))"|python)"m"
    fi
fi

if [ x${NOPTION} = x ]; then NOPTION=$hardware_cores ; fi
if [ x${TASKS_PER_NODE} = x ]; then
    if [ x${MEMORY} = x ]; then
	TASKS_PER_NODE=$hardware_cores
    else
	mem=$(echo ${MEMORY}|sed -e 's/m/*1024*1024/' -e 's/g/*1024*1024*1024/' -e 's/$/))/' -e 's/^/import math; print int(math.ceil(1.0*/' |python)
	TASKS_PER_NODE=$(echo "import math; print(int(math.floor(${hardware_memory}*1024.*1024.*1024./${mem})))"|python)
    fi
fi

if [ ${TASKS_PER_NODE} -gt ${NOPTION} ]; then TASKS_PER_NODE=${NOPTION}; fi

if [ x${MEMORY} = x ]; then
    MEMORY=$(echo "import math; print(int(math.floor(128.0*${hardware_memory}/${TASKS_PER_NODE})))"|python)"m"
fi

if [ x$verbose != x ]; then
    echo QUEUE=$QUEUE
    echo MEMORY=$MEMORY
    echo TASKS_PER_NODE=$TASKS_PER_NODE
    echo NOPTION=$NOPTION
fi
					       

if [ x${PROJECT} == xnone ]; then # use the special value 'none' in qmolpro.rc to denote that -P must be given later
  echo "Project missing. Specify it with -P (possible in $HOME/.${this}rc), or via the PROJECT environment variable"
  exit 1;
fi

if [ x${garbage} != x -a x${scratchdir} != x ]; then # garbage-collect any outstanding scratch directories
#fixme
    find $scratchdir -name 'SLURM.*' -mtime -"$garbage" -print0 | xargs -0  rm -rf
fi

if [ $parse_opts -eq 1 ] ; then
cat << EOF
Usage: $SCRIPT -n CPUS/TASKS_PER_NODE -h HH[:MM[:SS]] [-v] [-k] -W MOLPRO_OPTION INPUT_FILES
EOF
exit 1
fi



if [ ! -z $verbose ]; then
echo 'Processors:      ' $NOPTION
echo 'Tasks per node:  ' $TASKS_PER_NODE
echo 'Memory:          ' $MEMORY
fi;
DIR=`/bin/pwd`

mem=$(echo ${MEMORY}|sed -e 's/m/*1024*1024/' -e 's/g/*1024*1024*1024/' -e 's/$/\/1024\/1024))/' -e 's/^/import math; print int(math.ceil(1.0*/' |python)
SBATCHARGS="$SBATCHARGS --ntasks=$NOPTION --mem-per-cpu=$mem --ntasks-per-node=${TASKS_PER_NODE} -p ${QUEUE} -A ${PROJECT}"
#SBATCHARGS="$SBATCHARGS --time=0-00:20 "

if [ ! -z $debug ]; then debug='export MOLPRO_GA_DEBUG=1' ; fi
export SCW_TPN_OVERRIDE=1

for file in $* ; do
jobname=`basename ${file}|sed -e 's/\.[a-zA-Z0-9]*$//'`
qjobname=`echo "$jobname" | sed -e 's,[-+.],,g' -e 's,\(..........\).*,\1,'`
echo sbatch $SBATCHARGS --job-name=${qjobname}
sbatch $SBATCHARGS --job-name=${qjobname} --output=${qjobname}-slurm-%J.out << EOF
#! /bin/sh
echo "hello from start of job \$TMPDIR"
echo "Project $PROJECT"
if [ -r .bashrc ]; then  . .bashrc ; fi
#module purge
# need to find a better way of ensuring the right modules
for  i in \$(echo $LOADEDMODULES|sed -e 's/:/ /g') ; do module load \$i; done
module list
export MOLPRO_OPTIONS="$MOLPRO_OPTIONS"
export PATH=$PATH:\$JOBPATH:\$PATH
export SCRATCHDIR=${scratchdir}/SLURM.\${SLURM_JOBID}
# the right variable name?
export OMP_NUM_THREADS=\${THREADS:-1}
$debug
echo cd $PWD
cd $PWD
date
hostname
echo PATH=\$PATH
which $prog
if [ $prog = molpro ]; then
echo $prog -m ${MEMORY} -n $NOPTION -d \$SCRATCHDIR $OPTION $file
srun mkdir -p \$SCRATCHDIR
time $prog -v -m ${MEMORY} -n $NOPTION -d \$SCRATCHDIR $OPTION $file
ls -l \$SCRATCHDIR
if test -z $keeptmp ; then
 srun rm -rf \$SCRATCHDIR
fi
else
echo $prog $OPTION $file
time $prog $OPTION $file
fi
env
df -h
vmstat -sSM
grep -c ^processor /proc/cpuinfo
EOF

done
